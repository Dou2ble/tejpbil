<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/vite.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vite + TS</title>
  <script type="module" crossorigin>(function () {const n = document.createElement("link").relList; if (n && n.supports && n.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r); new MutationObserver(r => {for (const o of r) if (o.type === "childList") for (const c of o.addedNodes) c.tagName === "LINK" && c.rel === "modulepreload" && i(c)}).observe(document, {childList: !0, subtree: !0}); function e(r) {const o = {}; return r.integrity && (o.integrity = r.integrity), r.referrerPolicy && (o.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? o.credentials = "include" : r.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o} function i(r) {if (r.ep) return; r.ep = !0; const o = e(r); fetch(r.href, o)} })(); const $ = document, W = window, Et = $.documentElement, A = $.createElement.bind($), St = A("div"), X = A("table"), Jt = A("tbody"), gt = A("tr"), {isArray: j, prototype: xt} = Array, {concat: Gt, filter: et, indexOf: _t, map: Tt, push: Yt, slice: At, some: it, splice: Xt} = xt, Qt = /^#(?:[\w-]|\\.|[^\x00-\xa0])*$/, Zt = /^\.(?:[\w-]|\\.|[^\x00-\xa0])*$/, tn = /<.+>/, nn = /^\w+$/; function rt(t, n) {const e = en(n); return !t || !e && !T(n) && !h(n) ? [] : !e && Zt.test(t) ? n.getElementsByClassName(t.slice(1).replace(/\\/g, "")) : !e && nn.test(t) ? n.getElementsByTagName(t) : n.querySelectorAll(t)} class U {constructor(n, e) {if (!n) return; if (tt(n)) return n; let i = n; if (g(n)) {const r = e || $; if (i = Qt.test(n) && T(r) ? r.getElementById(n.slice(1).replace(/\\/g, "")) : tn.test(n) ? Lt(n) : tt(r) ? r.find(n) : g(r) ? u(r).find(n) : rt(n, r), !i) return } else if (O(n)) return this.ready(n); (i.nodeType || i === W) && (i = [i]), this.length = i.length; for (let r = 0, o = this.length; r < o; r++)this[r] = i[r]} init(n, e) {return new U(n, e)} } const s = U.prototype, u = s.init; u.fn = u.prototype = s; s.length = 0; s.splice = Xt; typeof Symbol == "function" && (s[Symbol.iterator] = xt[Symbol.iterator]); function tt(t) {return t instanceof U} function P(t) {return !!t && t === t.window} function T(t) {return !!t && t.nodeType === 9} function en(t) {return !!t && t.nodeType === 11} function h(t) {return !!t && t.nodeType === 1} function rn(t) {return !!t && t.nodeType === 3} function sn(t) {return typeof t == "boolean"} function O(t) {return typeof t == "function"} function g(t) {return typeof t == "string"} function y(t) {return t === void 0} function M(t) {return t === null} function Ot(t) {return !isNaN(parseFloat(t)) && isFinite(t)} function st(t) {if (typeof t != "object" || t === null) return !1; const n = Object.getPrototypeOf(t); return n === null || n === Object.prototype} u.isWindow = P; u.isFunction = O; u.isArray = j; u.isNumeric = Ot; u.isPlainObject = st; function d(t, n, e) {if (e) {let i = t.length; for (; i--;)if (n.call(t[i], i, t[i]) === !1) return t} else if (st(t)) {const i = Object.keys(t); for (let r = 0, o = i.length; r < o; r++) {const c = i[r]; if (n.call(t[c], c, t[c]) === !1) return t} } else for (let i = 0, r = t.length; i < r; i++)if (n.call(t[i], i, t[i]) === !1) return t; return t} u.each = d; s.each = function (t) {return d(this, t)}; s.empty = function () {return this.each((t, n) => {for (; n.firstChild;)n.removeChild(n.firstChild)})}; function F(...t) {const n = sn(t[0]) ? t.shift() : !1, e = t.shift(), i = t.length; if (!e) return {}; if (!i) return F(n, u, e); for (let r = 0; r < i; r++) {const o = t[r]; for (const c in o) n && (j(o[c]) || st(o[c])) ? ((!e[c] || e[c].constructor !== o[c].constructor) && (e[c] = new o[c].constructor), F(n, e[c], o[c])) : e[c] = o[c]} return e} u.extend = F; s.extend = function (t) {return F(s, t)}; const on = /\S+/g; function q(t) {return g(t) ? t.match(on) || [] : []} s.toggleClass = function (t, n) {const e = q(t), i = !y(n); return this.each((r, o) => {h(o) && d(e, (c, f) => {i ? n ? o.classList.add(f) : o.classList.remove(f) : o.classList.toggle(f)})})}; s.addClass = function (t) {return this.toggleClass(t, !0)}; s.removeAttr = function (t) {const n = q(t); return this.each((e, i) => {h(i) && d(n, (r, o) => {i.removeAttribute(o)})})}; function un(t, n) {if (t) {if (g(t)) {if (arguments.length < 2) {if (!this[0] || !h(this[0])) return; const e = this[0].getAttribute(t); return M(e) ? void 0 : e} return y(n) ? this : M(n) ? this.removeAttr(t) : this.each((e, i) => {h(i) && i.setAttribute(t, n)})} for (const e in t) this.attr(e, t[e]); return this} } s.attr = un; s.removeClass = function (t) {return arguments.length ? this.toggleClass(t, !1) : this.attr("class", "")}; s.hasClass = function (t) {return !!t && it.call(this, n => h(n) && n.classList.contains(t))}; s.get = function (t) {return y(t) ? At.call(this) : (t = Number(t), this[t < 0 ? t + this.length : t])}; s.eq = function (t) {return u(this.get(t))}; s.first = function () {return this.eq(0)}; s.last = function () {return this.eq(-1)}; function cn(t) {return y(t) ? this.get().map(n => h(n) || rn(n) ? n.textContent : "").join("") : this.each((n, e) => {h(e) && (e.textContent = t)})} s.text = cn; function E(t, n, e) {if (!h(t)) return; const i = W.getComputedStyle(t, null); return e ? i.getPropertyValue(n) || void 0 : i[n] || t.style[n]} function b(t, n) {return parseInt(E(t, n), 10) || 0} function pt(t, n) {return b(t, `border${n ? "Left" : "Top"}Width`) + b(t, `padding${n ? "Left" : "Top"}`) + b(t, `padding${n ? "Right" : "Bottom"}`) + b(t, `border${n ? "Right" : "Bottom"}Width`)} const Q = {}; function fn(t) {if (Q[t]) return Q[t]; const n = A(t); $.body.insertBefore(n, null); const e = E(n, "display"); return $.body.removeChild(n), Q[t] = e !== "none" ? e : "block"} function mt(t) {return E(t, "display") === "none"} function Rt(t, n) {const e = t && (t.matches || t.webkitMatchesSelector || t.msMatchesSelector); return !!e && !!n && e.call(t, n)} function K(t) {return g(t) ? (n, e) => Rt(e, t) : O(t) ? t : tt(t) ? (n, e) => t.is(e) : t ? (n, e) => e === t : () => !1} s.filter = function (t) {const n = K(t); return u(et.call(this, (e, i) => n.call(e, i, e)))}; function x(t, n) {return n ? t.filter(n) : t} s.detach = function (t) {return x(this, t).each((n, e) => {e.parentNode && e.parentNode.removeChild(e)}), this}; const an = /^\s*<(\w+)[^>]*>/, ln = /^<(\w+)\s*\/?>(?:<\/\1>)?$/, yt = {"*": St, tr: Jt, td: gt, th: gt, thead: X, tbody: X, tfoot: X}; function Lt(t) {if (!g(t)) return []; if (ln.test(t)) return [A(RegExp.$1)]; const n = an.test(t) && RegExp.$1, e = yt[n] || yt["*"]; return e.innerHTML = t, u(e.childNodes).detach().get()} u.parseHTML = Lt; s.has = function (t) {const n = g(t) ? (e, i) => rt(t, i).length : (e, i) => i.contains(t); return this.filter(n)}; s.not = function (t) {const n = K(t); return this.filter((e, i) => (!g(t) || h(i)) && !n.call(i, e, i))}; function S(t, n, e, i) {const r = [], o = O(n), c = i && K(i); for (let f = 0, w = t.length; f < w; f++)if (o) {const a = n(t[f]); a.length && Yt.apply(r, a)} else {let a = t[f][n]; for (; a != null && !(i && c(-1, a));)r.push(a), a = e ? a[n] : null} return r} function Pt(t) {return t.multiple && t.options ? S(et.call(t.options, n => n.selected && !n.disabled && !n.parentNode.disabled), "value") : t.value || ""} function hn(t) {return arguments.length ? this.each((n, e) => {const i = e.multiple && e.options; if (i || Ft.test(e.type)) {const r = j(t) ? Tt.call(t, String) : M(t) ? [] : [String(t)]; i ? d(e.options, (o, c) => {c.selected = r.indexOf(c.value) >= 0}, !0) : e.checked = r.indexOf(e.value) >= 0} else e.value = y(t) || M(t) ? "" : t}) : this[0] && Pt(this[0])} s.val = hn; s.is = function (t) {const n = K(t); return it.call(this, (e, i) => n.call(e, i, e))}; u.guid = 1; function C(t) {return t.length > 1 ? et.call(t, (n, e, i) => _t.call(i, n) === e) : t} u.unique = C; s.add = function (t, n) {return u(C(this.get().concat(u(t, n).get())))}; s.children = function (t) {return x(u(C(S(this, n => n.children))), t)}; s.parent = function (t) {return x(u(C(S(this, "parentNode"))), t)}; s.index = function (t) {const n = t ? u(t)[0] : this[0], e = t ? this : u(n).parent().children(); return _t.call(e, n)}; s.closest = function (t) {const n = this.filter(t); if (n.length) return n; const e = this.parent(); return e.length ? e.closest(t) : n}; s.siblings = function (t) {return x(u(C(S(this, n => u(n).parent().children().not(n)))), t)}; s.find = function (t) {return u(C(S(this, n => rt(t, n))))}; const dn = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, gn = /^$|^module$|\/(java|ecma)script/i, pn = ["type", "src", "nonce", "noModule"]; function mn(t, n) {const e = u(t); e.filter("script").add(e.find("script")).each((i, r) => {if (gn.test(r.type) && Et.contains(r)) {const o = A("script"); o.text = r.textContent.replace(dn, ""), d(pn, (c, f) => {r[f] && (o[f] = r[f])}), n.head.insertBefore(o, null), n.head.removeChild(o)} })} function yn(t, n, e, i, r) {i ? t.insertBefore(n, e ? t.firstChild : null) : t.nodeName === "HTML" ? t.parentNode.replaceChild(n, t) : t.parentNode.insertBefore(n, e ? t : t.nextSibling), r && mn(n, t.ownerDocument)} function _(t, n, e, i, r, o, c, f) {return d(t, (w, a) => {d(u(a), (Y, B) => {d(u(n), (dt, p) => {const D = e ? B : p, l = e ? p : B, R = e ? Y : dt; yn(D, R ? l.cloneNode(!0) : l, i, r, !R)}, f)}, c)}, o), n} s.after = function () {return _(arguments, this, !1, !1, !1, !0, !0)}; s.append = function () {return _(arguments, this, !1, !1, !0)}; function wn(t) {if (!arguments.length) return this[0] && this[0].innerHTML; if (y(t)) return this; const n = /<script[\s>]/.test(t); return this.each((e, i) => {h(i) && (n ? u(i).empty().append(t) : i.innerHTML = t)})} s.html = wn; s.appendTo = function (t) {return _(arguments, this, !0, !1, !0)}; s.wrapInner = function (t) {return this.each((n, e) => {const i = u(e), r = i.contents(); r.length ? r.wrapAll(t) : i.append(t)})}; s.before = function () {return _(arguments, this, !1, !0)}; s.wrapAll = function (t) {let n = u(t), e = n[0]; for (; e.children.length;)e = e.firstElementChild; return this.first().before(n), this.appendTo(e)}; s.wrap = function (t) {return this.each((n, e) => {const i = u(t)[0]; u(e).wrapAll(n ? i.cloneNode(!0) : i)})}; s.insertAfter = function (t) {return _(arguments, this, !0, !1, !1, !1, !1, !0)}; s.insertBefore = function (t) {return _(arguments, this, !0, !0)}; s.prepend = function () {return _(arguments, this, !1, !0, !0, !0, !0)}; s.prependTo = function (t) {return _(arguments, this, !0, !0, !0, !1, !1, !0)}; s.contents = function () {return u(C(S(this, t => t.tagName === "IFRAME" ? [t.contentDocument] : t.tagName === "TEMPLATE" ? t.content.childNodes : t.childNodes)))}; s.next = function (t, n, e) {return x(u(C(S(this, "nextElementSibling", n, e))), t)}; s.nextAll = function (t) {return this.next(t, !0)}; s.nextUntil = function (t, n) {return this.next(n, !0, t)}; s.parents = function (t, n) {return x(u(C(S(this, "parentElement", !0, n))), t)}; s.parentsUntil = function (t, n) {return this.parents(n, t)}; s.prev = function (t, n, e) {return x(u(C(S(this, "previousElementSibling", n, e))), t)}; s.prevAll = function (t) {return this.prev(t, !0)}; s.prevUntil = function (t, n) {return this.prev(n, !0, t)}; s.map = function (t) {return u(Gt.apply([], Tt.call(this, (n, e) => t.call(n, e, n))))}; s.clone = function () {return this.map((t, n) => n.cloneNode(!0))}; s.offsetParent = function () {return this.map((t, n) => {let e = n.offsetParent; for (; e && E(e, "position") === "static";)e = e.offsetParent; return e || Et})}; s.slice = function (t, n) {return u(At.call(this, t, n))}; const bn = /-([a-z])/g; function ot(t) {return t.replace(bn, (n, e) => e.toUpperCase())} s.ready = function (t) {const n = () => setTimeout(t, 0, u); return $.readyState !== "loading" ? n() : $.addEventListener("DOMContentLoaded", n), this}; s.unwrap = function () {return this.parent().each((t, n) => {if (n.tagName === "BODY") return; const e = u(n); e.replaceWith(e.children())}), this}; s.offset = function () {const t = this[0]; if (!t) return; const n = t.getBoundingClientRect(); return {top: n.top + W.pageYOffset, left: n.left + W.pageXOffset}}; s.position = function () {const t = this[0]; if (!t) return; const n = E(t, "position") === "fixed", e = n ? t.getBoundingClientRect() : this.offset(); if (!n) {const i = t.ownerDocument; let r = t.offsetParent || i.documentElement; for (; (r === i.body || r === i.documentElement) && E(r, "position") === "static";)r = r.parentNode; if (r !== t && h(r)) {const o = u(r).offset(); e.top -= o.top + b(r, "borderTopWidth"), e.left -= o.left + b(r, "borderLeftWidth")} } return {top: e.top - b(t, "marginTop"), left: e.left - b(t, "marginLeft")}}; const Nt = {class: "className", contenteditable: "contentEditable", for: "htmlFor", readonly: "readOnly", maxlength: "maxLength", tabindex: "tabIndex", colspan: "colSpan", rowspan: "rowSpan", usemap: "useMap"}; s.prop = function (t, n) {if (t) {if (g(t)) return t = Nt[t] || t, arguments.length < 2 ? this[0] && this[0][t] : this.each((e, i) => {i[t] = n}); for (const e in t) this.prop(e, t[e]); return this} }; s.removeProp = function (t) {return this.each((n, e) => {delete e[Nt[t] || t]})}; const Cn = /^--/; function ut(t) {return Cn.test(t)} const Z = {}, {style: $n} = St, En = ["webkit", "moz", "ms"]; function Sn(t, n = ut(t)) {if (n) return t; if (!Z[t]) {const e = ot(t), i = `${e[0].toUpperCase()}${e.slice(1)}`, r = `${e} ${En.join(`${i} `)}${i}`.split(" "); d(r, (o, c) => {if (c in $n) return Z[t] = c, !1})} return Z[t]} const xn = {animationIterationCount: !0, columnCount: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, gridArea: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnStart: !0, gridRow: !0, gridRowEnd: !0, gridRowStart: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0}; function Dt(t, n, e = ut(t)) {return !e && !xn[t] && Ot(n) ? `${n}px` : n} function _n(t, n) {if (g(t)) {const e = ut(t); return t = Sn(t, e), arguments.length < 2 ? this[0] && E(this[0], t, e) : t ? (n = Dt(t, n, e), this.each((i, r) => {h(r) && (e ? r.style.setProperty(t, n) : r.style[t] = n)})) : this} for (const e in t) this.css(e, t[e]); return this} s.css = _n; function Mt(t, n) {try {return t(n)} catch {return n} } const Tn = /^\s+|\s+$/; function wt(t, n) {const e = t.dataset[n] || t.dataset[ot(n)]; return Tn.test(e) ? e : Mt(JSON.parse, e)} function An(t, n, e) {e = Mt(JSON.stringify, e), t.dataset[ot(n)] = e} function On(t, n) {if (!t) {if (!this[0]) return; const e = {}; for (const i in this[0].dataset) e[i] = wt(this[0], i); return e} if (g(t)) return arguments.length < 2 ? this[0] && wt(this[0], t) : y(n) ? this : this.each((e, i) => {An(i, t, n)}); for (const e in t) this.data(e, t[e]); return this} s.data = On; function kt(t, n) {const e = t.documentElement; return Math.max(t.body[`scroll${n}`], e[`scroll${n}`], t.body[`offset${n}`], e[`offset${n}`], e[`client${n}`])} d([!0, !1], (t, n) => {d(["Width", "Height"], (e, i) => {const r = `${n ? "outer" : "inner"}${i}`; s[r] = function (o) {if (this[0]) return P(this[0]) ? n ? this[0][`inner${i}`] : this[0].document.documentElement[`client${i}`] : T(this[0]) ? kt(this[0], i) : this[0][`${n ? "offset" : "client"}${i}`] + (o && n ? b(this[0], `margin${e ? "Top" : "Left"}`) + b(this[0], `margin${e ? "Bottom" : "Right"}`) : 0)}})}); d(["Width", "Height"], (t, n) => {const e = n.toLowerCase(); s[e] = function (i) {if (!this[0]) return y(i) ? void 0 : this; if (!arguments.length) return P(this[0]) ? this[0].document.documentElement[`client${n}`] : T(this[0]) ? kt(this[0], n) : this[0].getBoundingClientRect()[e] - pt(this[0], !t); const r = parseInt(i, 10); return this.each((o, c) => {if (!h(c)) return; const f = E(c, "boxSizing"); c.style[e] = Dt(e, r + (f === "border-box" ? pt(c, !t) : 0))})}}); const bt = "___cd"; s.toggle = function (t) {return this.each((n, e) => {if (!h(e)) return; const i = mt(e); (y(t) ? i : t) ? (e.style.display = e[bt] || "", mt(e) && (e.style.display = fn(e.tagName))) : i || (e[bt] = E(e, "display"), e.style.display = "none")})}; s.hide = function () {return this.toggle(!1)}; s.show = function () {return this.toggle(!0)}; const Ct = "___ce", ct = ".", ft = {focus: "focusin", blur: "focusout"}, vt = {mouseenter: "mouseover", mouseleave: "mouseout"}, Rn = /^(mouse|pointer|contextmenu|drag|drop|click|dblclick)/i; function at(t) {return vt[t] || ft[t] || t} function lt(t) {const n = t.split(ct); return [n[0], n.slice(1).sort()]} s.trigger = function (t, n) {if (g(t)) {const [i, r] = lt(t), o = at(i); if (!o) return this; const c = Rn.test(o) ? "MouseEvents" : "HTMLEvents"; t = $.createEvent(c), t.initEvent(o, !0, !0), t.namespace = r.join(ct), t.___ot = i} t.___td = n; const e = t.___ot in ft; return this.each((i, r) => {e && O(r[t.___ot]) && (r[`___i${t.type}`] = !0, r[t.___ot](), r[`___i${t.type}`] = !1), r.dispatchEvent(t)})}; function Bt(t) {return t[Ct] = t[Ct] || {}} function Ln(t, n, e, i, r) {const o = Bt(t); o[n] = o[n] || [], o[n].push([e, i, r]), t.addEventListener(n, r)} function Wt(t, n) {return !n || !it.call(n, e => t.indexOf(e) < 0)} function H(t, n, e, i, r) {const o = Bt(t); if (n) o[n] && (o[n] = o[n].filter(([c, f, w]) => {if (r && w.guid !== r.guid || !Wt(c, e) || i && i !== f) return !0; t.removeEventListener(n, w)})); else for (n in o) H(t, n, e, i, r)} s.off = function (t, n, e) {if (y(t)) this.each((i, r) => {!h(r) && !T(r) && !P(r) || H(r)}); else if (g(t)) O(n) && (e = n, n = ""), d(q(t), (i, r) => {const [o, c] = lt(r), f = at(o); this.each((w, a) => {!h(a) && !T(a) && !P(a) || H(a, f, c, n, e)})}); else for (const i in t) this.off(i, t[i]); return this}; s.remove = function (t) {return x(this, t).detach().off(), this}; s.replaceWith = function (t) {return this.before(t).remove()}; s.replaceAll = function (t) {return u(t).replaceWith(this), this}; function Pn(t, n, e, i, r) {if (!g(t)) {for (const o in t) this.on(o, n, e, t[o], r); return this} return g(n) || (y(n) || M(n) ? n = "" : y(e) ? (e = n, n = "") : (i = e, e = n, n = "")), O(i) || (i = e, e = void 0), i ? (d(q(t), (o, c) => {const [f, w] = lt(c), a = at(f), Y = f in vt, B = f in ft; a && this.each((dt, p) => {if (!h(p) && !T(p) && !P(p)) return; const D = function (l) {if (l.target[`___i${l.type}`]) return l.stopImmediatePropagation(); if (l.namespace && !Wt(w, l.namespace.split(ct)) || !n && (B && (l.target !== p || l.___ot === a) || Y && l.relatedTarget && p.contains(l.relatedTarget))) return; let R = p; if (n) {let L = l.target; for (; !Rt(L, n);)if (L === p || (L = L.parentNode, !L)) return; R = L} Object.defineProperty(l, "currentTarget", {configurable: !0, get() {return R} }), Object.defineProperty(l, "delegateTarget", {configurable: !0, get() {return p} }), Object.defineProperty(l, "data", {configurable: !0, get() {return e} }); const zt = i.call(R, l, l.___td); r && H(p, a, w, n, D), zt === !1 && (l.preventDefault(), l.stopPropagation())}; D.guid = i.guid = i.guid || u.guid++, Ln(p, a, w, n, D)})}), this) : this} s.on = Pn; function Nn(t, n, e, i) {return this.on(t, n, e, i, !0)} s.one = Nn; const Dn = /\r?\n/g; function Mn(t, n) {
      return `&${encodeURIComponent(t)}=${encodeURIComponent(n.replace(Dn, `\r
`))}`
    } const kn = /file|reset|submit|button|image/i, Ft = /radio|checkbox/i; s.serialize = function () {let t = ""; return this.each((n, e) => {d(e.elements || [e], (i, r) => {if (r.disabled || !r.name || r.tagName === "FIELDSET" || kn.test(r.type) || Ft.test(r.type) && !r.checked) return; const o = Pt(r); if (!y(o)) {const c = j(o) ? o : [o]; d(c, (f, w) => {t += Mn(r.name, w)})} })}), t.slice(1)}; let vn = 0, Bn = 1, Wn = 2, Fn = 4, Hn = 8, ht = u("#ws-button"), I = u("#ws-status"), V = u("#up"), z = u("#left"), J = u("#down"), G = u("#right"), In = u("#stop"), Ht = u(document), k = u("#last-command"), jn = u("#interface"), Un = u("#login-container"), It = u("#password"), qn = u("#login"), $t = u("#error-message"); var m = null; function v(t) {
      m != null && m.readyState == 1 && m.send(t + `\r
`)
    } function jt() {v(Bn), k.text("forward"), V.addClass("active")} function Ut() {v(Fn), k.text("left"), z.addClass("active")} function qt() {v(Wn), k.text("backward"), J.addClass("active")} function Kt() {v(Hn), k.text("right"), G.addClass("active")} function N() {v(vn), k.text("stop"), V.removeClass("active"), z.removeClass("active"), J.removeClass("active"), G.removeClass("active")} function Kn(t) { } function Vn() {I.text("open"), ht.text("disconnect")} function zn() {I.text("closed"), ht.text("connect"), m.onopen = null, m.onclose = null, m.onmessage = null, m = null} let nt = new Set; Ht.on("keydown", t => {let n = t.code; if (!nt.has(n)) switch (nt.add(n), n) {case "KeyW": case "ArrowUp": jt(); break; case "KeyA": case "ArrowLeft": Ut(); break; case "KeyS": case "ArrowDown": qt(); break; case "KeyD": case "ArrowRight": Kt(); break}}); Ht.on("keyup", t => {let n = t.code; switch (nt.delete(n), n) {case "KeyW": case "KeyA": case "KeyS": case "KeyD": case "ArrowUp": case "ArrowLeft": case "ArrowDown": case "ArrowRight": N(); break}}); ht.on("click", () => {if (m == null) {try {m = new WebSocket("ws://" + window.location.host + ":81")} catch (t) {console.error(t), I.text(`failed to connect (${t})`); return } I.text("connecting"), m.onopen = Vn, m.onclose = zn, m.onmessage = Kn} else m.close()}); V.on("mousedown", jt); z.on("mousedown", Ut); J.on("mousedown", qt); G.on("mousedown", Kt); V.on("mouseup", N); z.on("mouseup", N); J.on("mouseup", N); G.on("mouseup", N); In.on("click", N); function Jn(t) {return new Promise(n => setTimeout(n, t))} async function Vt() {$t.text("Laddar..."), await Jn(500), It.val() == "tejpbil123" ? (Un.hide(), jn.show()) : $t.text("Fel lösenord!")} qn.on("click", Vt); It.on("keyup", t => {t.key == "Enter" && Vt()});
  </script>
  <style rel="stylesheet" crossorigin>
    @use "@material/slider/styles";

    :root {
      --button-size: 100px
    }

    body {
      background-color: #181819;
      color: #e2e2e3;
      text-align: center;
      font-family: monospace;
      font-size: 200%
    }

    h1 {
      font-size: 80px
    }

    input,
    button {
      background-color: transparent;
      border-color: #e2e2e2;
      border-style: solid;
      border-radius: 6px;
      color: #fff
    }

    #login-container {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      height: 100vh
    }

    #password {
      margin: 8px
    }

    #error-message {
      color: #fc5d7c
    }

    button:hover {
      background-color: #ffffff30
    }

    button:active {
      background-color: #ffffff40
    }

    .rocquet-league {
      border-radius: 12px;
      margin: 10000px 64px 64px
    }

    #ws-status-container {
      margin-top: 128px
    }

    .center {
      display: flex;
      justify-content: center
    }

    #button-container {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(2, var(--button-size));
      gap: 10px;
      justify-items: center;
      width: calc(var(--button-size) * 3);
      margin-top: 100px;
      margin-left: -20px
    }

    .direction-button {
      width: 100px;
      height: 100px;
      background-color: #ffffff10;
      border-radius: 6px
    }

    @keyframes active-animation {
      0% {
        background-color: #fff
      }

      to {
        background-color: #ffffff50
      }
    }

    .active {
      background-color: #ffffff50;
      animation-name: active-animation;
      animation-duration: .5s
    }

    #up {
      grid-column-start: 2
    }

    #left,
    #down,
    #right {
      grid-row-start: 2
    }
  </style>
</head>

<body>
  <div id="login-container">
    <div>
      <input type="password" id="password" />
      <button id="login">Login</button>
    </div>
    <div id="error-message"></div>
  </div>

  <div id="interface" style="display: none">
    <marquee behavior="scroll" direction="left" scrollamount="10">© 2024 Otto Roming</marquee>
    <h1>Otto's interface</h1>
    <div class="center">
      <div id="button-container">
        <div class="direction-button" id="up"></div>
        <div></div>
        <div class="direction-button" id="left"></div>
        <div></div>
        <div class="direction-button" id="down"></div>
        <div class="direction-button" id="right"></div>
      </div>
    </div>
    <p id="ws-status-container">
      Last sent command: <strong id="last-command">none</strong><br />
      WebSocket: <strong id="ws-status">closed</strong><br />
    </p>
    <!-- <input type="text" placeholder="192.168.1.2" id="ws-ip-input"> -->
    <button id="ws-button">connect</button>
    <!--<div id="slider"></div> -->

    <br />
    <button id="stop">stop</button>
  </div>
</body>

</html>
